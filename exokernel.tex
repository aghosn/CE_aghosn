\section{Exokernel: An Operating System Architecture for Application-Level Resource Management}

\subsection{Overview}

\subsection{Application knows best}
%end to end
%separation between policies and mechanisms
%
%
%
%Lib OS
%LibOS abstractions can be simpler and more specialized, especially since doesn't need to multiplex resources among competing applications with different demands.
%Can trust the application as well (since only one to be touched by it).
%Less kernel crossing
%Easy to get new standards
%portability if implemented on top of posix or other standards.
%OO and stuff like that to augment the libOS possibilities.
% support for dynamic linking and shared libs would reduce space required.
%
% Exokernel Design
% separate protection from management.
% Goal is to multiplex the physical resources and isolate apps from each other
% 
% 3 tasks: 1) track ownership, 2) ensure protection 3) revoke access to resources.
% secure bindings, visible revocation, abort protocol.
% 
% Design principles
% securely expose hardware: physical memory, CPU, disk memory, TLB, addressing context identifiers.
% interrupts, exceptions, cross-domain calls.
% Well => exokernel should avoid resource management.
% 
% Expose allocation: request specific physical resources.
% Expose Names: expose physical names, and also hardware things like disk position arm, TLB entries etc.
% Expose revocation: good to have physical names for that
% 
% Secure bindings
% 
% 

Application can manage ressources.
Kernel attack surface is smaller and should be less prone to bugs because it simply safely exposes resources.
Kernel and application responsabilities are better defined.
Crossing from user to kernel can be reduced to a strict minimum.
Avoid all the kernel bypass etc.
Reusability of libraries?\\

Allows for new abstractions closer to application's logic.
How hard would it be to implement lwc in exokernel? Not hard at all.\\

relevant to dataplanes as well.\\

How is scheduling implemented?

\subsection{Evaluation}

Must prove that it improves performance.
Security aspect of it?

\subsection{Discussion}
Main critic is how can you trust libOS?
Drivers reimplementation?
Application code is not enough sufficient, need the libOS as well.
Can we have a POSIX and Linux default set of LibOSes?
Debugging requires to understand the LibOS as well, which is bad...
\\

We can inject haven's solution for example with the set of guaranteed pages.
The application can put them into an enclave.
Find an attack scenario from corrupted host, and how we can prevent it.\\
