\section{Shielding Applications from an Untrusted Cloud with Haven}

\subsection{Overview}
%Define shieldied application.
%Give general goal and design.

%Shielded application.
%New problem is that you colocate applications in cloud services and want to be protected against a potentially corrupted host.
%Sandbox usually act the other way around.
%Rely on hardware mechanisms to do so by using the Intel SGX extension.\\
%
%Whole system is based on the libOS drawbridge.\\
%
%\adrien{Redacted}\\
%Haven[CITE] defines the notion of \emph{shielded execution}, i.e., protecting a program's data confidentiality and integrity from the host on which it runs.
%With the emergence of cloud services, Haven's authors identified TODO.
%While conveniently allowing a fast deployment of web-services, Cloud service providers often require their %clients to entrust them with unlimited access to their app-specific data.
%The privileged code, that is part of the host software stack, has unrestricted access to any resource lent to %the Cloud user.

Cloud computing providers enable even small organizations to deploy web-based services quickly, with low start-up costs, and efficiently adapt the amount of available resources to their current load.
On a machine, the cloud service provider's host divides physical resources among co-located applications from different origins.

While very attractive for their simplicity and adaptability, such services raise important confidentiality and integrity concerns that limit their adoption[CITE FROM HAVEN].
Cloud services implement a unidirectional isolation model where privileged code is protected from the unprivileged one, and retains unrestricted access to the application's data.
In other words, Cloud users are required to entrust the entire privileged software stack with their sensitive data.
Seeing as privacy and confidentiality are growing concerns, new techniques need to be devised to protect the application's data from a potentially compromised or malicious host.\\

Haven[CITE] is a system that leverages Intel software guard extension (SGX) to provide shielded execution of unmodified legacy applications on a commodity OS (windows).
Shielded execution allows to protect the \emph{confidentiality} and \emph{integrity} of a program's data from the host (e.g., the OS) on which it runs.
Confidentiality ensures that the program's intermediate states are not observable by the rest of the system, while integrity guarantees that if the program completes, the output is correct.
We briefly introduce the Intel SGX extension main features before presenting Haven's design.

%\adrien{Haven isolates against the host by running within an SGX enclave, a secure region of address space}

%Haven runs unmodified applications that do not incorporate in-depth defense against the host, i.e., they were written assuming that the underlying system is well-behaved.
%In order to preserve their integrity and protect against Iago attacks, i.e., a malicious host modifying the results of system calls to subvert an application, Haven integrates a library OS (LibOS) based on Microsoft Drawbridge[CITE] %that exposes the Windows 8 API.%
%The application runs on top of the LibOS, which in turns interacts with the untrusted host.
%\adrien{Should say SGX allow confidentiality and integrity, integrity also guaranteed by libOS.}

\subsection{The SGX extension}
%What is the SGX, what's an enclave, what can you do with it.
%Special pages that cannot be accessed or that trigger notification if accessed from outside of the enclave.
%How much pages can you put in there?\\
%
%Conclusion of this part must be that it's useful but cannot be enough to provide shielded execution.

The Intel Software Guard Extension (SGX) defines a set of new CPU instructions that allows to create and manipulate \emph{enclaves}.
An enclave is a portion of the user address space protected against unauthorized access or modification by software, even the ones running at a higher privileged level.
Data within an enclave is encrypted and integrity protected.
Any attempt to modify an enclave's data from outside of it results in a fault.

\adrien{soften the transition by talking about shadow state for pages and dynamicity of the whole thing.}

The processor relies on a secure storage, called the \emph{Enclave Page Cache} (EPC), to store and keep track of pages used by an executing enclave and metadata corresponding to these enclaves.
An enclave is created by the \lstinline{ECREATE} instruction, which initializes fields in the corresponding \emph{SGX Enclave Control Structure} (SECS).
SECS are not accessible by software and are stored within the EPC.
Each enclave is associated with a single SECS that holds metadata used by hardware to track the type of a page, the enclave it belongs to, ensure that the page is mapped at the correct virtual address, and accessed with respect to its associated access rights.
Memory pages are added to the enclave using the \lstinline{EADD} instruction.
Thanks to SGX2 extensions, dynamic memory allocation/removal, i.e., adding pages after an enclave's creation, is rendered possible via a cooperation between the enclave and the host OS.
The \lstinline{EAUG} allows the host to add a new page to the enclave, which in turns needs to acknowledge the new page with \lstinline{EACCEPT} before using it.
In thee same way, modifying access permissions and removing a page from an enclave relies on cooperative protocols that involve both the enclave and the host.

SGX threading relies on \emph{Thread Control Structure}s (TCS).
Each enclave can contain one or more TCS's.
A TCS specifies an entry point, \lstinline{OENTRY}, the starting point of the thread, and contains a special protected region, the \emph{State Save Area} (SSA), used to save and restore a thread context upon context switches.
Entering and exiting an enclave is done by respectively calling the \lstinline{EENTER} instruction on a TCS, and the \lstinline{EEXIT} instruction.

Asynchronous exits, on the other hand, are required to allow the underlying operating system to handle exceptions and interrupts.
Upon an asynchronous exit, the current SGX thread state as well as information about the cause of the exit are saved within the associated TCS.
Control can be given back to the enclave by either calling \lstinline{ERESUME}, which will resume the saved context, or \lstinline{EENTER}, which allows the enclave to inspect the exception, on the TCS.
The latter option allows the OS to report exceptions to the enclave.

\adrien{Maybe here for SGX2 where we can add and change permissions.}
%Different ways to protect:
%1. data in cache protected by TLB access.
%2. upon modification outside of the enclave, next load triggers a fault.
%3. maintains shadow page table.
%
%ECREATE init a structure in protected memory, EADD allows to add a page to enclave.
%A page allocated by the OS but must come from a specific physical pool (EPC)
%Hardware tracks type of EPC page, enclave it belongs to, checks type, current enclape maps the page at correct va, access okay with access rights.
%Paging is allowed. Prevent rollback attack with versioning number
%
%SGX provides attestation CPU-based. Can be used to prove identity and communicate with other enclaves.
%Processor manufacturer is root of trust for attestation.
%
%TCS to protect the enclave register file.
%EENTER on idle TCS
%Can read write outside of enclave but not execute.
%EEXIT or interrupt or exception. Entry and exit points specified by enclave.
%ERESUME on TCS to get back there. Also, state of enclave is saved and linked to TCS.
%Imperfect because OS can still observe some stuff.
%
%Cooperation between host OS and enclave.
%Allocate: host calls EAUG, enclave must EACCEPT.
%Other instructions to change permissions, require cooperation as well since need TLB shootdowns.
%
%SGX is very low level

\subsection{Design}
%The entire "stack" of Haven.
%This complicated thing where they have the special untrusted runtime as well.
%Things that must be explained:
%\begin{itemize}
%	\item picoprocess (to protect the host from the guest)
%	\item the enclave
%	\item the library operating system.
%	\item the shield module (how does it verify that host is actually correctly serving a system call?)
%	\item untrusted runtime
%	\item SGX driver and drawbridge host.
%\end{itemize}
%
%\adrien{Present from the optic of defending, show what needs to be done, cannot blindly trust the OS with services so need to reduce how much it is necessary to implicate it within the execution.}
%
%\adrien{Everybody obsessed with policy mechanism separation}
%
%\adrien{Maybe list all the problems somehow in the first remark.}
Haven leverages the low level isolation mechanisms provided by SGX to achieve shielded execution of legacy application binaries.
Since the host OS cannot be trusted, Haven provides most of the operating system services required by the application and manages policies and mechanisms for virtual resources, while the host retains management over physical ones.
This clear separation, coupled with defensive programming and careful interactions between guest and host, is supposed to facilitate Haven's resistance to Iago attacks, i.e., a malicious host exploiting the application's trust to achieve its goals.

Haven's definition of shielded execution requires to
\begin{enumerate*}
	\item bootstrap and validate the execution environment within the enclave
	\item implement virtual resource management within the enclave
	\item defend against a misbehaving host by verifying the result of every service requested from it
	\item prevent the host from gathering information on the enclave's state via exception handlers
\end{enumerate*}.
We now described how Haven's design addresses each of these concerns.
Figure [REF] provides an overview of Haven's runtime stack.
%We first present Haven's design before describing how each of these requirements is achieved.\\

Haven wraps the application within a sandbox provided by Drawbridge[CITE].
The application executes within a secured container, called \emph{picoprocess}, that interacts with a narrow ABI to request OS services.
A modified version of Windows 8 retrofitted into a LibOS implements the full OS API required by the application.
The LibOS is under user control and can be inspected and verified by the application.

In order to protect the application from Iago attacks, Haven relies on a \emph{shield module}.
The shield module exposes the drawbridge ABI to the LibOS and implements kernel functionalities and primitives such as memory management and thread synchronization.
It isolates the LibOS from a malicious host by validating all parameters and results that cross the border between trusted and untrusted parts of the runtime.
Such validations depend on the specific service required from the host OS, but mostly consist in sanity checks and observably consistent results.

The application, the LibOS, as well as the shield module execute within the enclave and are part of the trusted runtime, from the application's point of view.



%The  requirements for Haven imply that the application must be able to verify and trust its entire software stack that is part of the enclave, that services still provided by the underlying host must be treated as potentially misbehaving,  

%Drawbridge running on top of host kernel is responsible for the thing. 
%%Insert image.
%
% Rely on drawbridge to sandbox the application and have a trusted LibOS (trusted by the app itself).
% Exposes a narrower interface, and is verifiable by application. 
% Reducing interface means less ways to exploit and easier to control.
% 
% Shield module within the TCB. Gives core OS operations
% Also a bootloader for libos and application.
% There to protect against Iago attacks.
% 
% Untrusted interface (not in enclave)
% Policy mechanism separation
\adrien{Worth putting as insight before everything else. Should probably list such things (policy etc.) first and then give details.}
% Guest is responsible for virtual, host for physical
% Untrusted runtime
% create enclave, loading shield, forwarding calls to host
% Decided to prevent app from allocating anything outside of the enclave.
% Storage?
% 
% Threads and synchronization
% user level scheduling
% 
% Deployement is weird because also need to verify the VHD.
% Basically load and attest shield, then send the disk image.
% 
% Switching in and out of enclave requires specific mechanisms (clearing registers etc.)
% Requires copy for parameters passed by reference
% 
% Exception handler not really interesting.
% 
% 
% Requires to load all binaries directly because no demand loading possible.

\subsection{Evaluation}
Important to see the overhead introduced.
There is a security incentive, but the performance is also important because it is sacrificed here.
Running unmodified binaries is really an advantage.
Disk is still a limitation.

% Hard to evaluate on simulator, but looks like main penalties come from X.
% 31 to 54 percent slowdown comparend to VM 
% Enclave crossing is what impacts the most.
% They say it's gonna be acceptable but seems high.

\subsection{Discussion}
%Untrusted time
%VM exits.
%Cannot move as easily as a VM.
%Performance.
%Monitoring is hard when needed.

Still untrusted parts like the time.
Vm exits are a problem.
Cannot move it as easily as a VM, which is a problem since they target cloud deployment.
The performance penalty is pretty high, it improves security but degrades application performance significantly.
Cannot monitor, when on cloud services this is actually required and very important.\\

What we can take away from this paper is actually that applications deployment changed significantly.
Before, we could deploy on our own trusted servers.
Now multiple mutually untrusted applications are co-located on the host and we have this new bidirectional lack of trust between host and guest.
We need to address this issue.
Relying on hardware is an interesting solution because, compared to software, it is less amenable to bugs and hard to attack or circumvent.
The whole libOS thing is also interesting because it shows that by reimplementing the abstractions that regular applications rely on, we can run unmodified applications.
Although authors claim that this design can be easily ported, I see the lack of support for fork as a problem.
Why untrusted channel when SGX has a mechanism to attest a program?




