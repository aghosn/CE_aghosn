\section{Shielding Applications from an Untrusted Cloud with Haven}

\subsection{Overview}
%Define shieldied application.
%Give general goal and design.

%Shielded application.
%New problem is that you colocate applications in cloud services and want to be protected against a potentially corrupted host.
%Sandbox usually act the other way around.
%Rely on hardware mechanisms to do so by using the Intel SGX extension.\\
%
%Whole system is based on the libOS drawbridge.\\
%
%\adrien{Redacted}\\
%Haven[CITE] defines the notion of \emph{shielded execution}, i.e., protecting a program's data confidentiality and integrity from the host on which it runs.
%With the emergence of cloud services, Haven's authors identified TODO.
%While conveniently allowing a fast deployment of web-services, Cloud service providers often require their %clients to entrust them with unlimited access to their app-specific data.
%The privileged code, that is part of the host software stack, has unrestricted access to any resource lent to %the Cloud user.

Cloud computing providers enable even small organizations to deploy web-based services quickly, with low start-up costs, and efficiently adapt the amount of available resources to their current load.
On a machine, the cloud service provider's host divides physical resources among co-located applications from different origins.

While very attractive for their simplicity and adaptability, such services raise important confidentiality and integrity concerns that limit their adoption[CITE FROM HAVEN].
Cloud services implement a unidirectional isolation model where privileged code is protected from the unprivileged one, and retains unrestricted access to the application's data.
In other words, Cloud users are required to entrust the entire privileged software stack with their sensitive data.
Seeing as privacy and confidentiality are growing concerns, new techniques need to be devised to protect the application's data from a potentially compromised or malicious host.\\

Haven[CITE] is a system that leverages Intel software guard extension (SGX) to provide shielded execution of unmodified legacy applications on a commodity OS (windows).
Shielded execution allows to protect the \emph{confidentiality} and \emph{integrity} of a program's data from the host (e.g., the OS) on which it runs.
Confidentiality ensures that the program's intermediate states are not observable by the rest of the system, while integrity guarantees that if the program completes, the output is correct.
We briefly introduce the Intel SGX extension main features before presenting Haven's design.

%\adrien{Haven isolates against the host by running within an SGX enclave, a secure region of address space}

%Haven runs unmodified applications that do not incorporate in-depth defense against the host, i.e., they were written assuming that the underlying system is well-behaved.
%In order to preserve their integrity and protect against Iago attacks, i.e., a malicious host modifying the results of system calls to subvert an application, Haven integrates a library OS (LibOS) based on Microsoft Drawbridge[CITE] %that exposes the Windows 8 API.%
%The application runs on top of the LibOS, which in turns interacts with the untrusted host.
%\adrien{Should say SGX allow confidentiality and integrity, integrity also guaranteed by libOS.}

\subsection{The SGX extension}
%What is the SGX, what's an enclave, what can you do with it.
%Special pages that cannot be accessed or that trigger notification if accessed from outside of the enclave.
%How much pages can you put in there?\\
%
%Conclusion of this part must be that it's useful but cannot be enough to provide shielded execution.

The Intel Software Guard Extension (SGX) defines a set of new CPU instructions that allows to create and manipulate \emph{enclaves}.
An enclave is a portion of the user address space protected against unauthorized access or modification by software, even the ones running at a higher privileged level.
Data within an enclave is encrypted and integrity protected.
Any attempt to modify an enclave's data from outside of it results in a fault.

\adrien{Check the encrypted part above, it sounds weird.
soften the transition by talking about shadow state for pages and dynamicity of the whole thing.}

The processor relies on a secure storage, called the \emph{Enclave Page Cache} (EPC), to store and keep track of pages used by an executing enclave and metadata corresponding to these enclaves.
An enclave is created by the \lstinline{ECREATE} instruction, which initializes fields in the corresponding \emph{SGX Enclave Control Structure} (SECS).
SECS are not accessible by software and are stored within the EPC.
Each enclave is associated with a single SECS that holds metadata used by hardware to track the type of a page, the enclave it belongs to, ensure that the page is mapped at the correct virtual address, and accessed with respect to its associated access rights.
Memory pages are added to the enclave using the \lstinline{EADD} instruction.
Thanks to SGX2 extensions, dynamic memory allocation/removal, i.e., adding pages after an enclave's creation, is rendered possible via a cooperation between the enclave and the host OS.
The \lstinline{EAUG} allows the host to add a new page to the enclave, which in turns needs to acknowledge the new page with \lstinline{EACCEPT} before using it.
In the same way, modifying access permissions and removing a page from an enclave relies on cooperative protocols that involve both the enclave and the host.

SGX threading relies on \emph{Thread Control Structure}s (TCS).
Each enclave can contain one or more TCS's.
A TCS specifies an entry point, \lstinline{OENTRY}, the starting point of the thread, and contains a special protected region, the \emph{State Save Area} (SSA), used to save and restore a thread context upon context switches.
Entering and exiting an enclave is done by respectively calling the \lstinline{EENTER} instruction on a TCS, and the \lstinline{EEXIT} instruction.

Asynchronous exits, on the other hand, are required to allow the underlying operating system to handle exceptions and interrupts.
Upon an asynchronous exit, the current SGX thread state as well as information about the cause of the exit are saved within the associated TCS.
Control can be given back to the enclave by either calling \lstinline{ERESUME}, which will resume the saved context, or \lstinline{EENTER}, which allows the enclave to inspect the exception, on the TCS.
The latter option allows the OS to report exceptions to the enclave.
%Different ways to protect:
%1. data in cache protected by TLB access.
%2. upon modification outside of the enclave, next load triggers a fault.
%3. maintains shadow page table.
%
%ECREATE init a structure in protected memory, EADD allows to add a page to enclave.
%A page allocated by the OS but must come from a specific physical pool (EPC)
%Hardware tracks type of EPC page, enclave it belongs to, checks type, current enclape maps the page at correct va, access okay with access rights.
%Paging is allowed. Prevent rollback attack with versioning number
%
%SGX provides attestation CPU-based. Can be used to prove identity and communicate with other enclaves.
%Processor manufacturer is root of trust for attestation.
%
%TCS to protect the enclave register file.
%EENTER on idle TCS
%Can read write outside of enclave but not execute.
%EEXIT or interrupt or exception. Entry and exit points specified by enclave.
%ERESUME on TCS to get back there. Also, state of enclave is saved and linked to TCS.
%Imperfect because OS can still observe some stuff.
%
%Cooperation between host OS and enclave.
%Allocate: host calls EAUG, enclave must EACCEPT.
%Other instructions to change permissions, require cooperation as well since need TLB shootdowns.
%
%SGX is very low level

\subsection{Design}
%The entire "stack" of Haven.
%This complicated thing where they have the special untrusted runtime as well.
%Things that must be explained:
%\begin{itemize}
%	\item picoprocess (to protect the host from the guest)
%	\item the enclave
%	\item the library operating system.
%	\item the shield module (how does it verify that host is actually correctly serving a system call?)
%	\item untrusted runtime
%	\item SGX driver and drawbridge host.
%\end{itemize}
%
%\adrien{Present from the optic of defending, show what needs to be done, cannot blindly trust the OS with services so need to reduce how much it is necessary to implicate it within the execution.}
%
%\adrien{Everybody obsessed with policy mechanism separation}
%
%\adrien{Maybe list all the problems somehow in the first remark.}
Haven leverages the low level isolation mechanisms provided by SGX to achieve shielded execution of legacy application binaries.
Since the host OS cannot be trusted, Haven provides most of the operating system services required by the application and manages policies and mechanisms for virtual resources, while the host retains management over physical ones.
This clear separation, coupled with defensive programming and careful interactions between guest and host, is supposed to facilitate Haven's resistance to Iago attacks, i.e., a malicious host exploiting the application's trust to achieve its goals.

Haven's definition of shielded execution requires to
\begin{enumerate*}
	\item bootstrap and validate the execution environment within the enclave
	\item implement virtual resource management within the enclave
	\item defend against a misbehaving host by verifying the result of every service requested from it
	\item prevent the host from gathering information on the enclave's state via exception handlers
\end{enumerate*}.
We now describe how Haven's design addresses each of these concerns.
Figure [REF] provides an overview of Haven's runtime stack.
%We first present Haven's design before describing how each of these requirements is achieved.\\

Haven wraps the application within a sandbox provided by Drawbridge[CITE].
The application executes within a secured container, called \emph{picoprocess}, that interacts with a narrow ABI to request OS services.
A modified version of Windows 8 retrofitted into a LibOS implements the full OS API required by the application.
The LibOS is under user control and can be inspected and verified by the application.

In order to protect the application from Iago attacks, Haven relies on a \emph{shield module}.
The shield module exposes the drawbridge ABI to the LibOS and implements kernel functionalities and primitives such as memory management and thread synchronization.
It isolates the LibOS from a malicious host by validating all parameters and results that cross the border between trusted and untrusted parts of the runtime.
Such validations depend on the specific service required from the host OS, but mostly consist in sanity checks and observably consistent results.

The application, the LibOS, as well as the shield module, execute within the enclave and are part of the trusted runtime, from the application's point of view.

The untrusted interface that lives at the boundary of the enclave was designed to allow correctness verification by the shield, while being flexible enough to permit an efficient implementation of services on both sides.
In order to achieve both security and performance, Haven's authors decided to decouple policies from mechanisms.
The host is responsible for managing physical resources while the guest handles virtual ones.

Underneath the untrusted interface, an untrusted runtime module exists to forward calls between the guest and the host.
This module also acts as a bootstrap to create the enclave and load the shield.

Applications are deployed on the cloud as encrypted disk images that contain both the application and LibOS binaries.
The cloud service provider is responsible for creating the picoprocess and loading the untrusted runtime, which in turns creates the enclave and loads the shield module.
SGX attestation mechanism is used to compute a hash of the shield to verify its integrity.
Afterwards, the shield generates asymmetric cryptography keys, securely sends its public key to a machine controlled by the user along with proof that it was correctly initialized.
The user verifies the shield's integrity, encrypts the disk image with the public key, and sends it to the shield.
The application is then ready to be loaded.

As mentioned earlier, exception handling requires the host's intervention.
When an exception occurs in enclave mode, SGX saves the content of the registers and information about the fault within the TCS.
The exception is passed on to the host OS which can, as described earlier, either handle the fault, or report it back to the guest.
In the latter case, the shield verifies the legitimacy of the exception before reporting it to the LibOS.
Worth noting, as a context can only be resumed with \lstinline{EERESUME} from outside the enclave, an extra \lstinline{EEXIT} is required.
%The  requirements for Haven imply that the application must be able to verify and trust its entire software stack that is part of the enclave, that services still provided by the underlying host must be treated as potentially misbehaving,  
%Drawbridge running on top of host kernel is responsible for the thing. 
%%Insert image.
%
% Rely on drawbridge to sandbox the application and have a trusted LibOS (trusted by the app itself).
% Exposes a narrower interface, and is verifiable by application. 
% Reducing interface means less ways to exploit and easier to control.
% 
% Shield module within the TCB. Gives core OS operations
% Also a bootloader for libos and application.
% There to protect against Iago attacks.
% 
% Untrusted interface (not in enclave)
% Policy mechanism separation
% Guest is responsible for virtual, host for physical
% Untrusted runtime
% create enclave, loading shield, forwarding calls to host
% Decided to prevent app from allocating anything outside of the enclave.
% Storage?
% 
% Threads and synchronization
% user level scheduling
% 
% Deployement is weird because also need to verify the VHD.
% Basically load and attest shield, then send the disk image.
% 
% Switching in and out of enclave requires specific mechanisms (clearing registers etc.)
% Requires copy for parameters passed by reference
% 
% Exception handler not really interesting.
% 
% 
% Requires to load all binaries directly because no demand loading possible.
\subsection{Evaluation}
%Important to see the overhead introduced.
%There is a security incentive, but the performance is also important because it is sacrificed here.
%Running unmodified binaries is really an advantage.
%Disk is still a limitation.
%
% Hard to evaluate on simulator, but looks like main penalties come from X.
% 31 to 54 percent slowdown comparend to VM 
% Enclave crossing is what impacts the most.
% They say it's gonna be acceptable but seems high.
The performance evaluation is done within a simulation that emulates SGX performance for critical instructions such as: \lstinline{EENTER}, \lstinline{EEXIT}, \lstinline{ERESUME}, and asynchronous exits.
EPC access time is artificially modified by reducing the DRAM frequency on the test machine.
Haven's performance is measured against a Microsoft SQL Server benchmark and an Apache HTTP server one.
The measurements are compared with the performance achieved by running the application natively, in a Hyper-V VM, and in Drawbridge.
We note that Haven performs less efficiently than all other configuration for database benchmark, with a 13\% slowdown compared to Drawbridge.
On the HTTP server evaluation, with a dedicated filesystem, Haven is less efficient than other configurations but out-performs Drawbridge thanks to the read intensive nature of the workload that accesses pages located within the buffer cache inside the enclave.
Without the private filesystem, Haven incurs a 40\% slowdown compared to Drawbridge.

The authors experimented with synthetic delays for memory allocation and enclave crossing and reported how these affect Haven's performance.
This method enables to evaluate how these applications react to varying SGX instruction delays.
The database benchmark is unaffected by dynamic memory allocation overheads as a very small number of them occur during the execution.
Enclave crossing overheads are, however, impacting the overall performance.
For the HTTP server benchmark, both overheads seem to have an impact on the performance.

Varying the EPCL performance shows that memory-intensive workloads would see their performance decrease, although not proportionally as not all accesses are going to the EPC.
For example, the database benchmark suffered a 21\% slowdown when the memory system was slowed down by a third.

More generally, Haven's authors conservatively expect the performance slow down compared to a virtual machine to range from 31\% to 54\%.
\subsection{Discussion}
%Untrusted time
%VM exits.
%Cannot move as easily as a VM.
%Performance.
%Monitoring is hard when needed.

Still untrusted parts like the time.
Vm exits are a problem.
Cannot move it as easily as a VM, which is a problem since they target cloud deployment.
The performance penalty is pretty high, it improves security but degrades application performance significantly.
Cannot monitor, when on cloud services this is actually required and very important.\\

What we can take away from this paper is actually that applications deployment changed significantly.
Before, we could deploy on our own trusted servers.
Now multiple mutually untrusted applications are co-located on the host and we have this new bidirectional lack of trust between host and guest.
We need to address this issue.
Relying on hardware is an interesting solution because, compared to software, it is less amenable to bugs and hard to attack or circumvent.
The whole libOS thing is also interesting because it shows that by reimplementing the abstractions that regular applications rely on, we can run unmodified applications.
Also allows the application to verify most of the execution stack (e.g., inspect the libOS).
Although authors claim that this design can be easily ported, I see the lack of support for fork as a problem.
Why untrusted channel when SGX has a mechanism to attest a program?

\adrien{Key insight + how to link to exokernel: separation between physical resources and virtual ones, and separation between policies and mechanisms.}




