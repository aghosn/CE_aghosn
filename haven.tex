\section{Shielding Applications from an Untrusted Cloud with Haven}

Cloud computing service providers enable even small organizations to deploy web-based services quickly, with low start-up costs, and efficiently adapt the amount of available resources to their current load.
On a machine, the cloud service provider's host divides physical resources among co-located applications from different origins.

While attractive for their simplicity and adaptability, such services raise important confidentiality and integrity concerns that limit their adoption[CITE FROM HAVEN].
Cloud services implement a unidirectional isolation model where privileged code (the host) is protected from the unprivileged one (the guest), and retains unrestricted access to the application's data.
In other words, Cloud users are forced to entrust the entire Cloud privileged management software stack with their sensitive data and intellectual property.
Seeing as privacy and confidentiality are growing concerns, new techniques need to be devised to protect the application's data from a potentially compromised or malicious host.

Haven[CITE] is a system that leverages Intel Software Guard Extension (SGX) to provide shielded execution of unmodified legacy applications on a commodity OS (windows).
Shielded execution allows to protect the \emph{confidentiality} and \emph{integrity} of a program from the host (e.g., the OS) on which it runs.
Confidentiality ensures that the program's intermediate states are not observable by the rest of the system, while integrity guarantees that if the program completes, the output is correct.
We briefly introduce the Intel SGX extension main features before presenting Haven's design.

\subsection{The SGX extension}

\input{SGX}

\subsection{Design}

Haven leverages the low level isolation mechanisms provided by SGX to achieve shielded execution of legacy application binaries.
Since the host OS cannot be trusted, Haven provides most of the operating system services required by the application and manages policies and mechanisms for virtual resources, while the host retains management over physical ones.
This clear separation, coupled with defensive programming and careful interactions between guest and host, is supposed to facilitate Haven's resistance to Iago attacks, i.e., a malicious host exploiting the application's trust to achieve its goals.

Haven's definition of shielded execution requires to
\begin{enumerate*}
	\item bootstrap and validate the execution environment within the enclave,
	\item implement virtual resource management within the enclave,
	\item defend against a misbehaving host by verifying the result of every service requested from it, and
	\item prevent the host from gathering information on the enclave's state via exception handlers
\end{enumerate*}.
We now describe how Haven's design addresses each of these concerns.
Figure [REF] provides an overview of Haven's runtime stack.
The application, the LibOS, and the shield module form the trusted software base.
They are all encapsulated inside the enclave.

Haven wraps the application in a sandbox provided by Drawbridge[CITE].
The application executes within a secured container, called \emph{picoprocess}, that exposes a narrow ABI to request OS services.
As a standard sandboxing mechanism, the picoprocess protects the host from the guest.

The application relies on a trusted library operating system (LibOS) to request system services.
In Haven, the LibOS is a modified version of Windows 8, retrofitted into a set of libraries, that implements the full OS API.
The LibOS is under user control and can be inspected and verified by the application.

In order to protect the application from Iago attacks, Haven relies on a \emph{shield module}.
The shield module exposes the drawbridge ABI to the LibOS and implements kernel functionalities and primitives such as memory management and thread synchronization.
It isolates the LibOS from a malicious host by validating all parameters and results that cross the border between trusted and untrusted parts of the runtime.
Such validations depend on the specific service required from the host OS, but mostly consist in sanity checks and observably consistent results.

The untrusted interface at the boundary of the enclave was designed to allow correctness verification by the shield, while being flexible enough to permit an efficient implementation of services on both sides.
In order to achieve both security and performance, Haven's authors decided to decouple policies from mechanisms.
The host is responsible for managing physical resources while the guest handles virtual ones.

Underneath the untrusted interface, an untrusted runtime module exists to forward calls between the guest and the host.
This module also acts as a bootstrap to create the enclave and load the shield.

The host OS interacts with the enclave via the Drawbridge ABI and provides services relating to memory management, e.g., changing memory access rights or allocating untrusted virtual memory, thread signaling, access to external untrusted devices, e.g., storage, and to the system time.

Applications are deployed on the Cloud as encrypted disk images that contain both the application and LibOS binaries.
The Cloud service provider is responsible for creating the picoprocess and loading the untrusted runtime, which in turns creates the enclave and loads the shield module.
SGX remote attestation mechanism is used to compute a quote of the shield and verify its integrity as well as the enclave's environment.
Afterwards, the shield generates asymmetric cryptography keys, securely sends its public key to a machine controlled by the user along with the quote.
The user verifies the shield's integrity, encrypts the disk image with the public key, and sends it to the shield.
The application is then ready to be loaded.

Exception handling requires the host's intervention and must therefore be done with care to avoid leaking information about the enclave's state.
When an exception occurs in enclave mode, SGX saves the content of the registers and information about the fault within the current TCS.
A synthetic context for the exception is then created to prevent data leaks to the host.
This synthetic context is passed to the host OS which can either handle the exception, or report it back to the guest.
In the latter case, the shield verifies the legitimacy of the exception before reporting it to the LibOS.

Haven stacks several software layers, each existing to provide specific functionalities to the ones above it.
This layered architecture, coupled with the defensive programming design adopted, might introduce non-negligible overheads.
The next section focuses on Haven's reported performance.

%The  requirements for Haven imply that the application must be able to verify and trust its entire software stack that is part of the enclave, that services still provided by the underlying host must be treated as potentially misbehaving,  
%Drawbridge running on top of host kernel is responsible for the thing. 
%%Insert image.
%
% Rely on drawbridge to sandbox the application and have a trusted LibOS (trusted by the app itself).
% Exposes a narrower interface, and is verifiable by application. 
% Reducing interface means less ways to exploit and easier to control.
% 
% Shield module within the TCB. Gives core OS operations
% Also a bootloader for libos and application.
% There to protect against Iago attacks.
% 
% Untrusted interface (not in enclave)
% Policy mechanism separation
% Guest is responsible for virtual, host for physical
% Untrusted runtime
% create enclave, loading shield, forwarding calls to host
% Decided to prevent app from allocating anything outside of the enclave.
% Storage?
% 
% Threads and synchronization
% user level scheduling
% 
% Deployement is weird because also need to verify the VHD.
% Basically load and attest shield, then send the disk image.
% 
% Switching in and out of enclave requires specific mechanisms (clearing registers etc.)
% Requires copy for parameters passed by reference
% 
% Exception handler not really interesting.
% 
% 
% Requires to load all binaries directly because no demand loading possible.
\subsection{Evaluation}

\include{haven_perf}

\subsection{Discussion}
%Untrusted time
%VM exits.
%Cannot move as easily as a VM.
%Performance.
%Monitoring is hard when needed.

Still untrusted parts like the time.
Vm exits are a problem.
Cannot move it as easily as a VM, which is a problem since they target cloud deployment.
The performance penalty is pretty high, it improves security but degrades application performance significantly.
Cannot monitor, when on cloud services this is actually required and very important.\\

What we can take away from this paper is actually that applications deployment changed significantly.
Before, we could deploy on our own trusted servers.
Now multiple mutually untrusted applications are co-located on the host and we have this new bidirectional lack of trust between host and guest.
We need to address this issue.
Relying on hardware is an interesting solution because, compared to software, it is less amenable to bugs and hard to attack or circumvent.
The whole libOS thing is also interesting because it shows that by reimplementing the abstractions that regular applications rely on, we can run unmodified applications.
Also allows the application to verify most of the execution stack (e.g., inspect the libOS).
Although authors claim that this design can be easily ported, I see the lack of support for fork as a problem.
Why untrusted channel when SGX has a mechanism to attest a program?

\adrien{Key insight + how to link to exokernel: separation between physical resources and virtual ones, and separation between policies and mechanisms.}




